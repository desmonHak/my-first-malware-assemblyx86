     1                                  [bits 32]
     2                                  
     3                                  ;extern  _GLOBAL_OFFSET_TABLE_   ; in ELF 
     4                                  ;extern  __GLOBAL_OFFSET_TABLE_  ; in BSD
     5                                  
     6                                  ; OF = 1 
     7                                  %define JumpIfOverflow(symbol) jo symbol
     8                                  
     9                                  ; OF = 0 
    10                                  %define JumpIfNotOverflow(symbol) jno symbol
    11                                  
    12                                  ; SF = 1 
    13                                  %define JumpIfSign(symbol) js symbol
    14                                  
    15                                  ; SF = 0 
    16                                  %define JumpIfNotSign(symbol) jns symbol
    17                                  
    18                                  ; ZF = 1 	 
    19                                  %define JumpIfEqual(symbol) je symbol
    20                                  
    21                                  ;ZF = 0
    22                                  %define JumpIfNotEqual(symbol) jne symbol
    23                                  
    24                                  ; ZF = 1 	 
    25                                  %define JumpIfZero(symbol) jz symbol
    26                                  
    27                                  ; ZF = 0 
    28                                  %define JumpIfNotZero(symbol) jnz symbol
    29                                  
    30                                  %define STD_OUTPUT_HANDLE -11
    31                                  %define true 1
    32                                  %define false 0
    33                                  
    34                                  %define SIZE_INT8  1
    35                                  %define SIZE_INT16 2
    36                                  %define SIZE_INT32 4
    37                                  %define SIZE_INT64 8
    38                                  %define SIZE_INT(bits) bits/8
    39                                  
    40                                  section .bss nobits    alloc  noexec  write
    41 00000000 <res Dh>                    cpu_name resb 13
    42 0000000D ????????                    stdio resb 4
    43                                  
    44                                  section .rodata  progbits  alloc  noexec  nowrite
    45                                  
    46                                  section .text progbits  alloc  exec    nowrite
    47                                      global _WinMain@16           ; Declaracion de la funcion principal del programa
    48                                      extern _GetStdHandle@4       ; Declaracion de la funcion GetStdHandle de Windows
    49                                      extern _WriteFile@20         ; Declaracion de la funcion WriteFile de Windows
    50                                      extern _ExitProcess@4        ; Declaracion de la funcion ExitProcess de Windows
    51                                      extern _GetModuleHandleA@4
    52                                  
    53                                  ;; global _myfunc 
    54                                  ;; _myfunc:  push bp 
    55                                  ;;           mov bp,sp 
    56                                  ;;           sub sp,0x40            ; 64 bytes of local stack space 
    57                                  ;;           mov bx,[bp+4]          ; first parameter to function 
    58                                  ;;           ; some more code 
    59                                  ;;           mov sp,bp              ; undo "sub sp,0x40" above 
    60                                  ;;           pop bp 
    61                                  ;;           ret
    62                                  
    63                                  _IdFromBytesMem:
    64 00000000 55                      	push	ebp
    65 00000001 89E5                    	mov	ebp, esp
    66 00000003 83EC10                  	sub	esp, 16
    67 00000006 C745FC00000000          	mov	DWORD  [ebp-4], 0
    68                                      L8:
    69 0000000D 837DFC16                        cmp	DWORD  [ebp-4], 22
    70 00000011 7725                            ja	L10
    71 00000013 8B5508                          mov	edx, DWORD  [ebp+8]
    72 00000016 8B45FC                          mov	eax, DWORD  [ebp-4]
    73 00000019 01D0                            add	eax, edx
    74 0000001B 0FB600                          movzx	eax, BYTE  [eax]
    75 0000001E 3CB8                            cmp	al, -72
    76 00000020 7510                            jne	L6
    77 00000022 8B45FC                          mov	eax, DWORD  [ebp-4]
    78 00000025 8D5001                          lea	edx, [eax+1]
    79 00000028 8B4508                          mov	eax, DWORD  [ebp+8]
    80 0000002B 01D0                            add	eax, edx
    81 0000002D 0FB700                          movzx	eax, WORD  [eax]
    82 00000030 EB0C                            jmp	L7
    83                                      L6:
    84 00000032 8345FC01                        add	DWORD  [ebp-4], 1
    85 00000036 EBD5                            jmp	L8
    86                                      L10:
    87 00000038 90                              nop
    88 00000039 B800000000                      mov	eax, 0
    89                                      L7:
    90 0000003E C9                              leave
    91 0000003F C3                              ret
    92                                  
    93                                  _GetSyscallIdMem:
    94 00000040 55                      	push	ebp
    95 00000041 89E5                    	mov	ebp, esp
    96 00000043 83EC48                  	sub	esp, 72
    97 00000046 C70424[2B000000]        	mov	DWORD  [esp], ntdll_string
    98 0000004D B8[00000000]            	mov	eax, DWORD  _GetModuleHandleA@4
    99 00000052 FFD0                    	call	eax
   100 00000054 83EC04                  	sub	esp, 4
   101 00000057 8945E8                  	mov	DWORD  [ebp-24], eax
   102 0000005A 837DE800                	cmp	DWORD  [ebp-24], 0
   103 0000005E 750A                    	jne	L12
   104 00000060 B8FFFFFFFF              	mov	eax, -1
   105 00000065 E905010000              	jmp	L13
   106                                      L12:
   107 0000006A 8B45E8                          mov	eax, DWORD  [ebp-24]
   108 0000006D 8945E4                          mov	DWORD  [ebp-28], eax
   109 00000070 8B45E4                          mov	eax, DWORD  [ebp-28]
   110 00000073 8B403C                          mov	eax, DWORD  [eax+60]
   111 00000076 89C2                            mov	edx, eax
   112 00000078 8B45E8                          mov	eax, DWORD  [ebp-24]
   113 0000007B 01D0                            add	eax, edx
   114 0000007D 8945E0                          mov	DWORD  [ebp-32], eax
   115 00000080 8B45E0                          mov	eax, DWORD  [ebp-32]
   116 00000083 8B5078                          mov	edx, DWORD  [eax+120]
   117 00000086 8B45E8                          mov	eax, DWORD  [ebp-24]
   118 00000089 01D0                            add	eax, edx
   119 0000008B 8945DC                          mov	DWORD  [ebp-36], eax
   120 0000008E 8B45DC                          mov	eax, DWORD  [ebp-36]
   121 00000091 8B5020                          mov	edx, DWORD  [eax+32]
   122 00000094 8B45E8                          mov	eax, DWORD  [ebp-24]
   123 00000097 01D0                            add	eax, edx
   124 00000099 8945D8                          mov	DWORD  [ebp-40], eax
   125 0000009C 8B45DC                          mov	eax, DWORD  [ebp-36]
   126 0000009F 8B501C                          mov	edx, DWORD  [eax+28]
   127 000000A2 8B45E8                          mov	eax, DWORD  [ebp-24]
   128 000000A5 01D0                            add	eax, edx
   129 000000A7 8945D4                          mov	DWORD  [ebp-44], eax
   130 000000AA 8B45DC                          mov	eax, DWORD  [ebp-36]
   131 000000AD 8B5024                          mov	edx, DWORD  [eax+36]
   132 000000B0 8B45E8                          mov	eax, DWORD  [ebp-24]
   133 000000B3 01D0                            add	eax, edx
   134 000000B5 8945D0                          mov	DWORD  [ebp-48], eax
   135 000000B8 C745F400000000                  mov	DWORD  [ebp-12], 0
   136 000000BF E997000000                      jmp	L14
   137                                      L20:
   138 000000C4 8B45F4                          mov	eax, DWORD  [ebp-12]
   139 000000C7 8D148500000000                  lea	edx, [0+eax*4]
   140 000000CE 8B45D8                          mov	eax, DWORD  [ebp-40]
   141 000000D1 01D0                            add	eax, edx
   142 000000D3 8B10                            mov	edx, DWORD  [eax]
   143 000000D5 8B45E8                          mov	eax, DWORD  [ebp-24]
   144 000000D8 01D0                            add	eax, edx
   145 000000DA 8945CC                          mov	DWORD  [ebp-52], eax
   146 000000DD 8B4508                          mov	eax, DWORD  [ebp+8]
   147 000000E0 89442404                        mov	DWORD  [esp+4], eax
   148 000000E4 8B45CC                          mov	eax, DWORD  [ebp-52]
   149 000000E7 890424                          mov	DWORD  [esp], eax
   150 000000EA E8C4000000                      call	compare_strings
   151 000000EF 85C0                            test	eax, eax
   152 000000F1 7406                            je	L15
   153 000000F3 8345F401                        add	DWORD  [ebp-12], 1
   154 000000F7 EB62                            jmp	L14
   155                                      L15:
   156 000000F9 8B45F4                          mov	eax, DWORD  [ebp-12]
   157 000000FC 8D1400                          lea	edx, [eax+eax]
   158 000000FF 8B45D0                          mov	eax, DWORD  [ebp-48]
   159 00000102 01D0                            add	eax, edx
   160 00000104 0FB700                          movzx	eax, WORD  [eax]
   161 00000107 0FB7C0                          movzx	eax, ax
   162 0000010A 8D148500000000                  lea	edx, [0+eax*4]
   163 00000111 8B45D4                          mov	eax, DWORD  [ebp-44]
   164 00000114 01D0                            add	eax, edx
   165 00000116 8B10                            mov	edx, DWORD  [eax]
   166 00000118 8B45E8                          mov	eax, DWORD  [ebp-24]
   167 0000011B 01D0                            add	eax, edx
   168 0000011D 8945C8                          mov	DWORD  [ebp-56], eax
   169 00000120 C745EC00000000                  mov	DWORD  [ebp-20], 0
   170                                      L19:
   171 00000127 837DEC16                        cmp	DWORD  [ebp-20], 22
   172 0000012B 7727                            ja	L22
   173 0000012D 8B55C8                          mov	edx, DWORD  [ebp-56]
   174 00000130 8B45EC                          mov	eax, DWORD  [ebp-20]
   175 00000133 01D0                            add	eax, edx
   176 00000135 0FB600                          movzx	eax, BYTE  [eax]
   177 00000138 3CB8                            cmp	al, -72
   178 0000013A 7512                            jne	L18
   179 0000013C 8B45EC                          mov	eax, DWORD  [ebp-20]
   180 0000013F 8D5001                          lea	edx, [eax+1]
   181 00000142 8B45C8                          mov	eax, DWORD  [ebp-56]
   182 00000145 01D0                            add	eax, edx
   183 00000147 0FB700                          movzx	eax, WORD  [eax]
   184 0000014A 668945F2                        mov	WORD  [ebp-14], ax
   185                                      L18:
   186 0000014E 8345EC01                        add	DWORD  [ebp-20], 1
   187 00000152 EBD3                            jmp	L19
   188                                      L22:
   189 00000154 90                              nop
   190 00000155 0FB745F2                        movzx	eax, WORD  [ebp-14]
   191 00000159 EB14                            jmp	L13
   192                                      L14:
   193 0000015B 8B45DC                          mov	eax, DWORD  [ebp-36]
   194 0000015E 8B4018                          mov	eax, DWORD  [eax+24]
   195 00000161 3945F4                          cmp	DWORD  [ebp-12], eax
   196 00000164 0F825AFFFFFF                    jb	L20
   197 0000016A B800000000                      mov	eax, 0
   198                                      L13:
   199 0000016F C9                              leave
   200 00000170 C3                              ret
   201                                  
   202                                  
   203                                  cpuid_:
   204 00000171 55                          push ebp
   205 00000172 89E5                        mov ebp, esp
   206 00000174 83EC04                      sub esp, 4
   207                                  
   208                                      ; Obtener info del procesador:
   209                                      ; https://en.wikipedia.org/wiki/CPUID
   210 00000177 31C0                        xor eax, eax
   211 00000179 0FA2                        cpuid ; cpuid(eax = 0)
   212 0000017B 891D[00000000]              mov [cpu_name], ebx
   213 00000181 8915[04000000]              mov [cpu_name+4], edx
   214 00000187 890D[08000000]              mov [cpu_name+8], ecx
   215 0000018D C605[0C000000]0A            mov byte [cpu_name+12], 0xa ; introducir un salto de linea
   216                                      
   217 00000194 31C0                        xor eax, eax
   218 00000196 8945FC                      mov dword [ebp-4], eax ; lpOverlapped = 0
   219 00000199 8D45FC                      lea eax, [ebp-4]
   220 0000019C 50                          push eax               ; lpNumberOfBytesWritten
   221 0000019D 6A0D                        push 13                ; nNumberOfBytesToWrite
   222 0000019F 68[00000000]                push cpu_name          ; lpBuffer
   223 000001A4 FF35[0D000000]              push dword [stdio]     ;hFile
   224 000001AA E8(00000000)                call _WriteFile@20
   225                                      ; WriteFile(
   226                                      ;   hFile = stdio, 
   227                                      ;   lpBuffer = cpu_name, 
   228                                      ;   nNumberOfBytesToWrite = 13, 
   229                                      ;   lpNumberOfBytesWritten = (DWORD)&lpOverlapped, 
   230                                      ;   lpOverlapped = 0
   231                                      ; );
   232                                  
   233                                  
   234 000001AF 31C0                        xor eax, eax ; return 0
   235                                      ;not eax ; return -1
   236                                  
   237 000001B1 C9                          leave
   238 000001B2 C3                          ret
   239                                  
   240                                  ; int compare_strings(char *str1, char *str2)
   241                                  ; 0 = equals; -1 = diferentes
   242                                  compare_strings:
   243 000001B3 55                          push ebp
   244 000001B4 89E5                        mov ebp, esp
   245                                  
   246                                      ; Cargar los parámetros (direcciones de las cadenas) en registros
   247 000001B6 8B7508                      mov esi, [ebp + 8]   ; Primer parámetro: dirección de la primera cadena
   248 000001B9 8B7D0C                      mov edi, [ebp + 12]  ; Segundo parámetro: dirección de la segunda cadena
   249                                  
   250                                      ._compare_loop:
   251 000001BC AC                              lodsb            ; Cargar un carácter de la primera cadena en al
   252 000001BD 3A07                            cmp al, [edi]    ; Comparar el carácter cargado con el carácter correspondiente de la segunda cadena
   253 000001BF 7507                            jne ._not_equal  ; Si los caracteres son diferentes, salir del bucle
   254 000001C1 3C00                            cmp al, 0
   255 000001C3 740A                            je ._equal       ; Si el carácter es nulo (fin de cadena), salir del bucle
   256                                  
   257 000001C5 47                              inc edi            ; Incrementar la dirección de la segunda cadena
   258 000001C6 EBF4                            jmp ._compare_loop ; Repetir el bucle
   259                                  
   260                                      ._not_equal:
   261 000001C8 B8FFFFFFFF                      mov eax, -1 ; Retornar -1 (diferentes)
   262 000001CD EB02                            jmp ._end
   263                                  
   264                                      ._equal:
   265 000001CF 31C0                            xor eax, eax ; Retornar 0 (iguales)
   266                                      ._end:
   267 000001D1 C9                              leave
   268 000001D2 C3                              ret
   269                                  
   270                                  
   271                                  
   272                                  _WinMain@16:
   273                                  
   274                                      ; Reservar espacio en la pila para la variable local
   275 000001D3 83EC04                      sub esp, 4
   276                                  
   277                                      ; Obtener el identificador de la salida estándar
   278                                      ; HANDLE stdio = GetStdHandle(DWORD STD_OUTPUT_HANDLE)
   279 000001D6 6AF5                        push STD_OUTPUT_HANDLE       ; Parametro: STD_OUTPUT_HANDLE (-11)
   280 000001D8 E8(00000000)                call _GetStdHandle@4         ; Llama a la funcion GetStdHandle para obtener el identificador de la salida estándar
   281 000001DD A3[0D000000]                mov [stdio], eax             ; Almacena el identificador de la salida estándar en stdio
   282                                  
   283 000001E2 68[0F000000]                push dword procesadorIntel
   284 000001E7 68[1D000000]                push dword procesadorAMD
   285 000001EC E8C2FFFFFF                  call compare_strings
   286                                  
   287 000001F1 83F800                      cmp eax, 0
   288 000001F4 7405                        je bb_
   289                                  
   290 000001F6 E876FFFFFF                  call cpuid_
   291                                      bb_:
   292                                  
   293                                      ;cli ; desactivar interupciones IF = 0
   294                                  
   295                                      ; Escribir el mensaje en la salida estándar
   296                                      ; BOOL WriteFile(
   297                                      ;   [in]                HANDLE       hFile,
   298                                      ;   [in]                LPCVOID      lpBuffer,
   299                                      ;   [in]                DWORD        nNumberOfBytesToWrite,
   300                                      ;   [out, optional]     LPDWORD      lpNumberOfBytesWritten,
   301                                      ;   [in, out, optional] LPOVERLAPPED lpOverlapped
   302                                      ; );
   303 000001FB EB00                        jmp ._a
   304                                      ;db 0x90, 0xaf, 0x11, 0xa0, 0x90, 0x90, 0xaf, 0x11, 0xa0, 0x90
   305                                      ._a:
   306                                  
   307                                      
   308                                      ;lea eax, [function_name]
   309                                      ;push eax
   310                                      ;extern _printf
   311                                      ;call _GetSyscallIdMem
   312                                      ;push ax
   313                                      ;push msg
   314                                      ;call	_printf
   315                                  
   316 000001FD 6A00                        push 0                       ; Parametro: lpOverlapped (0)
   317 000001FF 8D442404                    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
   318 00000203 50                          push eax                     ; Parametro: lpNumberOfBytesWritten
   319 00000204 6A0F                        push dword lengthmessage     ; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
   320 00000206 68[00000000]                push message                 ; Parametro: lpBuffer (puntero al mensaje)
   321 0000020B FF35[0D000000]              push dword [stdio]           ; Parametro: hFile (identificador de la salida estándar)
   322                                      ; WriteFile(
   323                                      ;   hFile = stdio, 
   324                                      ;   lpBuffer = message, 
   325                                      ;   nNumberOfBytesToWrite = lengthmessage, 
   326                                      ;   lpNumberOfBytesWritten = (DWORD)&lpOverlapped, 
   327                                      ;   lpOverlapped = 0
   328                                      ; );
   329                                  
   330                                      ;times 5 dw 0xcd10
   331 00000211 EB00                        jmp ._b
   332                                      ._b:
   333                                      ;sti ; activar interupciones IF = 1
   334 00000213 E8(00000000)                call _WriteFile@20           ; Llama a la funcion WriteFile para escribir el mensaje en la consola
   335                                      ;times 2 db 0x90
   336                                  
   337                                  
   338                                  
   339                                  
   340                                  
   341                                  
   342                                  
   343                                      ; Salir del programa
   344                                      ; ExitProcess(0)
   345 00000218 6A00                        push 0                       ; Parametro: exitCode (0)
   346 0000021A E8(00000000)                call _ExitProcess@4          ; Llama a la funcion ExitProcess para terminar el programa
   347                                  
   348                                  
   349                                  section .data progbits  alloc  noexec  write
   350 00000000 48656C6C6F2C20576F-         message db 'Hello, World!', 0xa, 0x0  ; Definición del mensaje a mostrar en la consola
   350 00000009 726C64210A00       
   351                                      lengthmessage: equ $-message
   352                                  
   353 0000000F 47656E75696E65496E-         procesadorIntel db "GenuineIntel", 0xa, 0x0
   353 00000018 74656C0A00         
   354                                      lengthprocesadorIntel: equ $-procesadorIntel
   355 0000001D 41757468656E746963-         procesadorAMD   db "AuthenticAMD", 0xa, 0x0
   355 00000026 414D440A00         
   356                                      ;lengthprocesadorAMD: equ $-procesadorAMD
   357                                  
   358 0000002B 6E74646C6C2E646C6C-         ntdll_string db "ntdll.dll",0x0
   358 00000034 00                 
   359                                      lengthntdll_string: equ $-ntdll_string
   360                                  
   361 00000035 53797363616C6C2049-         format_string db "Syscall ID for function '%s': %u", 10, 0
   361 0000003E 4420666F722066756E-
   361 00000047 6374696F6E20272573-
   361 00000050 273A2025750A00     
   362 00000057 4E74416C706344656C-         function_name db "NtAlpcDeleteResourceReserve", 0
   362 00000060 6574655265736F7572-
   362 00000069 636552657365727665-
   362 00000072 00                 
   363 00000073 53797363616C6C2049-         msg db "Syscall ID for function '%s': %u", 0xa, 0x0
   363 0000007C 4420666F722066756E-
   363 00000085 6374696F6E20272573-
   363 0000008E 273A2025750A00     
   364                                  
   365                                  
   366                                  ;segment _DATA 
   367                                  
   368                                  ;times 510 -( $ - $$ ) db 0
