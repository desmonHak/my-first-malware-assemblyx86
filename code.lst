<<<<<<< HEAD
     1                                  [bits 32]
     2                                  
     3                                  ;extern  _GLOBAL_OFFSET_TABLE_   ; in ELF 
     4                                  ;extern  __GLOBAL_OFFSET_TABLE_  ; in BSD
     5                                  
     6                                  ; OF = 1 
     7                                  %define JumpIfOverflow(symbol) jo symbol
     8                                  
     9                                  ; OF = 0 
    10                                  %define JumpIfNotOverflow(symbol) jno symbol
    11                                  
    12                                  ; SF = 1 
    13                                  %define JumpIfSign(symbol) js symbol
    14                                  
    15                                  ; SF = 0 
    16                                  %define JumpIfNotSign(symbol) jns symbol
    17                                  
    18                                  ; ZF = 1 	 
    19                                  %define JumpIfEqual(symbol) je symbol
    20                                  
    21                                  ;ZF = 0
    22                                  %define JumpIfNotEqual(symbol) jne symbol
    23                                  
    24                                  ; ZF = 1 	 
    25                                  %define JumpIfZero(symbol) jz symbol
    26                                  
    27                                  ; ZF = 0 
    28                                  %define JumpIfNotZero(symbol) jnz symbol
    29                                  
    30                                  %define STD_OUTPUT_HANDLE -11
    31                                  %define true 1
    32                                  %define false 0
    33                                  
    34                                  %define SIZE_INT8  1
    35                                  %define SIZE_INT16 2
    36                                  %define SIZE_INT32 4
    37                                  %define SIZE_INT64 8
    38                                  %define SIZE_INT(bits) bits/8
    39                                  
    40                                  section .bss nobits    alloc  noexec  write
    41 00000000 <res Ch>                    cpu_name resb 12
    42                                  
    43                                  section .rodata  progbits  alloc  noexec  nowrite
    44                                  
    45                                  section .text progbits  alloc  exec    nowrite
    46                                      global _WinMain@16           ; Declaracion de la funcion principal del programa
    47                                      extern _GetStdHandle@4       ; Declaracion de la funcion GetStdHandle de Windows
    48                                      extern _WriteFile@20         ; Declaracion de la funcion WriteFile de Windows
    49                                      extern _ExitProcess@4        ; Declaracion de la funcion ExitProcess de Windows
    50                                  
    51                                  ;; global _myfunc 
    52                                  ;; _myfunc:  push bp 
    53                                  ;;           mov bp,sp 
    54                                  ;;           sub sp,0x40            ; 64 bytes of local stack space 
    55                                  ;;           mov bx,[bp+4]          ; first parameter to function 
    56                                  ;;           ; some more code 
    57                                  ;;           mov sp,bp              ; undo "sub sp,0x40" above 
    58                                  ;;           pop bp 
    59                                  ;;           ret
    60                                  
    61                                  cpuid_:
    62 00000000 55                          push ebp
    63 00000001 89E5                        mov ebp, esp
    64                                      ;sub esp
    65                                  
    66                                      ; "GenuineIntel" = 0x47,0x65,0x6e,0x75,0x69,0x6e,0x65,0x49,0x6e,0x74,0x65,0x6c
    67                                  
    68 00000003 60                          pusha
    69 00000004 31C0                        xor eax, eax ; EAX = 0
    70 00000006 0FA2                        cpuid ; cpuid(EAX = 0) -> return char*(ebx, edx, ecx)
    71 00000008 891D[00000000]              mov [cpu_name], ebx
    72 0000000E 8915[04000000]              mov [cpu_name+4], edx
    73 00000014 890D[08000000]              mov [cpu_name+8], ecx
    74                                      
    75 0000001A 81FB47656E75                cmp ebx, 0x756e6547 ; Genu(0x47656e75) -> uneG(0x756e6547)
    76 00000020 61                          popa
    77                                  
    78 00000021 6A00                        push 0
    79                                      ; El procesador es Intel
    80 00000023 C744240400000000            mov dword [esp+4], 0 
    81 0000002B 8D442404                    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    82 0000002F 50                          push eax
    83                                  
    84                                  
    85 00000030 7511                        JumpIfNotEqual(.next_if)
    86                                      ;JumpIfEqual(._thisIntel)
    87                                  
    88                                      ._thisIntel:   
    89                                      
    90                                          ; El procesador es Intel
    91                                          ;mov dword ptr [esp+4], 0 
    92                                          ;lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    93                                  
    94                                          ;sub esp, 4*3
    95                                  
    96                                          ;push eax                     ; Parametro: lpNumberOfBytesWritten
    97 00000032 6A0E                            push dword lengthprocesadorIntel; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
    98 00000034 68[0F000000]                    push procesadorIntel                 ; Parametro: lpBuffer (puntero al mensaje)
    99 00000039 53                              push ebx                     ; Parametro: hFile (identificador de la salida estándar)
   100 0000003A E8(00000000)                    call _WriteFile@20
   101 0000003F 31C0                            xor eax, eax
   102 00000041 EB1D                            jmp ._return
   103                                  
   104                                      .next_if:
   105 00000043 81FB41757468                    cmp ebx, 0x68747541 ; Auth(0x41757468) -> htuA(0x68747541)
   106                                          ;JumpIfEqual(._thisAMD)
   107 00000049 7511                            JumpIfNotEqual(._err)
   108                                  
   109                                      ._thisAMD:   
   110                                          ; El procesador es AMD
   111                                          ;lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
   112                                          ;push eax                     ; Parametro: lpNumberOfBytesWritten
   113 0000004B 6A0E                            push dword lengthprocesadorIntel; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
   114 0000004D 68[1D000000]                    push procesadorAMD                 ; Parametro: lpBuffer (puntero al mensaje)
   115 00000052 53                              push ebx                     ; Parametro: hFile (identificador de la salida estándar)
   116 00000053 E8(00000000)                    call _WriteFile@20
   117 00000058 31C0                            xor eax, eax
   118 0000005A EB04                            jmp ._return
   119                                  
   120                                      ._err:
   121                                          ; eax = -1
   122 0000005C 31C0                            xor eax, eax
   123 0000005E F7D0                            not eax
   124                                          ; return -1
   125                                  
   126                                      ._return:
   127                                          ;mov esp, ebp
   128                                          ;pop ebp
   129 00000060 C9                              leave ; mov esp,ebp / pop ebp 
   130 00000061 C3                              ret
   131                                          ; return ?
   132                                  
   133                                  
   134                                  _WinMain@16:
   135                                  
   136                                      ; Reservar espacio en la pila para la variable local
   137 00000062 83EC04                      sub esp, 4
   138                                  
   139                                      ; Obtener el identificador de la salida estándar
   140                                      ; HANDLE ebx = GetStdHandle(DWORD STD_OUTPUT_HANDLE)
   141 00000065 6AF5                        push STD_OUTPUT_HANDLE       ; Parametro: STD_OUTPUT_HANDLE (-11)
   142 00000067 E8(00000000)                call _GetStdHandle@4         ; Llama a la funcion GetStdHandle para obtener el identificador de la salida estándar
   143 0000006C 89C3                        mov ebx, eax                 ; Almacena el identificador de la salida estándar en ebx
   144                                  
   145 0000006E E88DFFFFFF                  call cpuid_
   146                                  
   147                                      ;cli ; desactivar interupciones IF = 0
   148                                  
   149                                      ; Escribir el mensaje en la salida estándar
   150                                      ; BOOL WriteFile(
   151                                      ;   [in]                HANDLE       hFile,
   152                                      ;   [in]                LPCVOID      lpBuffer,
   153                                      ;   [in]                DWORD        nNumberOfBytesToWrite,
   154                                      ;   [out, optional]     LPDWORD      lpNumberOfBytesWritten,
   155                                      ;   [in, out, optional] LPOVERLAPPED lpOverlapped
   156                                      ; );
   157                                      ; WriteFile(ebx, message, lengthmessage, eax, 0)    
   158 00000073 EB00                        jmp ._a
   159                                      ;db 0x90, 0xaf, 0x11, 0xa0, 0x90, 0x90, 0xaf, 0x11, 0xa0, 0x90
   160                                      ._a:
   161 00000075 6A00                        push 0                       ; Parametro: lpOverlapped (0)
   162                                  
   163 00000077 8D442404                    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
   164 0000007B 50                          push eax                     ; Parametro: lpNumberOfBytesWritten
   165 0000007C 6A0C                        push dword 12     ; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
   166 0000007E 68[00000000]                push cpu_name                 ; Parametro: lpBuffer (puntero al mensaje)
   167 00000083 53                          push ebx                     ; Parametro: hFile (identificador de la salida estándar)
   168                                  
   169                                      ;times 5 dw 0xcd10
   170 00000084 EB00                        jmp ._b
   171                                      ._b:
   172                                      ;sti ; activar interupciones IF = 1
   173 00000086 E8(00000000)                call _WriteFile@20           ; Llama a la funcion WriteFile para escribir el mensaje en la consola
   174                                      ;times 2 db 0x90
   175                                  
   176                                      ; Salir del programa
   177                                      ; ExitProcess(0)
   178 0000008B 6A00                        push 0                       ; Parametro: exitCode (0)
   179 0000008D E8(00000000)                call _ExitProcess@4          ; Llama a la funcion ExitProcess para terminar el programa
   180                                  
   181                                  
   182                                  section .data progbits  alloc  noexec  write
   183 00000000 48656C6C6F2C20576F-         message db 'Hello, World!', 0xa, 0x0  ; Definición del mensaje a mostrar en la consola
   183 00000009 726C64210A00       
   184                                      lengthmessage: equ $-message
   185                                  
   186 0000000F 47656E75696E65496E-         procesadorIntel db "GenuineIntel", 0xa, 0x0
   186 00000018 74656C0A00         
   187                                      lengthprocesadorIntel: equ $-procesadorIntel
   188 0000001D 41757468656E746963-         procesadorAMD   db "AuthenticAMD", 0xa, 0x0
   188 00000026 414D440A00         
   189                                      ;lengthprocesadorAMD: equ $-procesadorAMD
   190                                  
   191                                  ;segment _DATA 
   192                                  
   193                                  ;times 510 -( $ - $$ ) db 0
=======
     1                                  [bits 32]
     2                                  
     3                                  ; OF = 1 
     4                                  %define JumpIfOverflow(symbol) jo symbol
     5                                  
     6                                  ; OF = 0 
     7                                  %define JumpIfNotOverflow(symbol) jno symbol
     8                                  
     9                                  ; SF = 1 
    10                                  %define JumpIfSign(symbol) js symbol
    11                                  
    12                                  ; SF = 0 
    13                                  %define JumpIfNotSign(symbol) jns symbol
    14                                  
    15                                  ; ZF = 1 	 
    16                                  %define JumpIfEqual(symbol) je symbol
    17                                  
    18                                  ;ZF = 0
    19                                  %define JumpIfNotEqual(symbol) jne symbol
    20                                  
    21                                  ; ZF = 1 	 
    22                                  %define JumpIfZero(symbol) jz symbol
    23                                  
    24                                  ; ZF = 0 
    25                                  %define JumpIfNotZero(symbol) jnz symbol
    26                                  
    27                                  %define STD_OUTPUT_HANDLE -11
    28                                  %define true 1
    29                                  %define false 0
    30                                  
    31                                  section .bss
    32                                  
    33                                  section .text
    34                                      global _WinMain@16           ; Declaracion de la funcion principal del programa
    35                                      extern _GetStdHandle@4       ; Declaracion de la funcion GetStdHandle de Windows
    36                                      extern _WriteFile@20         ; Declaracion de la funcion WriteFile de Windows
    37                                      extern _ExitProcess@4        ; Declaracion de la funcion ExitProcess de Windows
    38                                  
    39                                  cpuid_:
    40 00000000 55                          push ebp
    41 00000001 89E5                        mov ebp, esp
    42                                  
    43                                      ; "GenuineIntel" = 0x47,0x65,0x6e,0x75,0x69,0x6e,0x65,0x49,0x6e,0x74,0x65,0x6c
    44                                  
    45 00000003 60                          pusha
    46 00000004 31C0                        xor eax, eax ; EAX = 0
    47 00000006 0FA2                        cpuid ; cpuid(EAX = 0) -> return char*(ebx, edx, ecx)
    48 00000008 81FB47656E75                cmp ebx, 0x756e6547 ; Genu(0x47656e75) -> uneG(0x756e6547)
    49 0000000E 61                          popa
    50 0000000F 7502                        JumpIfNotEqual(.next_if)
    51 00000011 740A                        JumpIfEqual(._thisIntel)
    52                                  
    53                                      .next_if:
    54 00000013 81FB41757468                    cmp ebx, 0x68747541 ; Auth(0x41757468) -> htuA(0x68747541)
    55 00000019 741A                            JumpIfEqual(._thisAMD)
    56 0000001B 7530                            JumpIfNotEqual(._err)
    57                                  
    58                                      
    59                                      ._thisIntel:   
    60                                      
    61                                          ; El procesador es Intel
    62 0000001D 6A00                            push 0 
    63 0000001F 8D442404                        lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    64 00000023 50                              push eax                     ; Parametro: lpNumberOfBytesWritten
    65 00000024 6A0E                            push dword lengthprocesadorIntel; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
    66 00000026 68[0F000000]                    push procesadorIntel                 ; Parametro: lpBuffer (puntero al mensaje)
    67 0000002B 53                              push ebx                     ; Parametro: hFile (identificador de la salida estándar)
    68 0000002C E8(00000000)                    call _WriteFile@20
    69 00000031 31C0                            xor eax, eax
    70 00000033 EB1C                            jmp ._return
    71                                  
    72                                      ._thisAMD:   
    73                                          ; El procesador es AMD
    74 00000035 6A00                            push 0 
    75 00000037 8D442404                        lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    76 0000003B 50                              push eax                     ; Parametro: lpNumberOfBytesWritten
    77 0000003C 6A0E                            push dword lengthprocesadorIntel; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
    78 0000003E 68[1D000000]                    push procesadorAMD                 ; Parametro: lpBuffer (puntero al mensaje)
    79 00000043 53                              push ebx                     ; Parametro: hFile (identificador de la salida estándar)
    80 00000044 E8(00000000)                    call _WriteFile@20
    81 00000049 31C0                            xor eax, eax
    82 0000004B EB04                            jmp ._return
    83                                  
    84                                      ._err:
    85                                          ; eax = -1
    86 0000004D 31C0                            xor eax, eax
    87 0000004F F7D0                            not eax
    88                                          ; return -1
    89                                  
    90                                      ._return:
    91 00000051 89EC                            mov esp, ebp
    92 00000053 5D                              pop ebp
    93 00000054 C3                              ret
    94                                          ; return ?
    95                                  
    96                                  
    97                                  _WinMain@16:
    98                                  
    99                                      ; Reservar espacio en la pila para la variable local
   100 00000055 83EC04                      sub esp, 4
   101                                  
   102                                      ; Obtener el identificador de la salida estándar
   103                                      ; HANDLE ebx = GetStdHandle(DWORD STD_OUTPUT_HANDLE)
   104 00000058 6AF5                        push STD_OUTPUT_HANDLE       ; Parametro: STD_OUTPUT_HANDLE (-11)
   105 0000005A E8(00000000)                call _GetStdHandle@4         ; Llama a la funcion GetStdHandle para obtener el identificador de la salida estándar
   106 0000005F 89C3                        mov ebx, eax                 ; Almacena el identificador de la salida estándar en ebx
   107                                  
   108 00000061 E89AFFFFFF                  call cpuid_
   109                                  
   110                                      ;cli ; desactivar interupciones IF = 0
   111                                  
   112                                      ; Escribir el mensaje en la salida estándar
   113                                      ; BOOL WriteFile(
   114                                      ;   [in]                HANDLE       hFile,
   115                                      ;   [in]                LPCVOID      lpBuffer,
   116                                      ;   [in]                DWORD        nNumberOfBytesToWrite,
   117                                      ;   [out, optional]     LPDWORD      lpNumberOfBytesWritten,
   118                                      ;   [in, out, optional] LPOVERLAPPED lpOverlapped
   119                                      ; );
   120                                      ; WriteFile(ebx, message, lengthmessage, eax, 0)    
   121 00000066 EB00                        jmp ._a
   122                                      ;db 0x90, 0xaf, 0x11, 0xa0, 0x90, 0x90, 0xaf, 0x11, 0xa0, 0x90
   123                                      ._a:
   124 00000068 6A00                        push 0                       ; Parametro: lpOverlapped (0)
   125                                  
   126 0000006A 8D442404                    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
   127 0000006E 50                          push eax                     ; Parametro: lpNumberOfBytesWritten
   128 0000006F 6A0F                        push dword lengthmessage     ; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
   129 00000071 68[00000000]                push message                 ; Parametro: lpBuffer (puntero al mensaje)
   130 00000076 53                          push ebx                     ; Parametro: hFile (identificador de la salida estándar)
   131                                  
   132                                      ;times 5 dw 0xcd10
   133 00000077 EB00                        jmp ._b
   134                                      ._b:
   135                                      ;sti ; activar interupciones IF = 1
   136 00000079 E8(00000000)                call _WriteFile@20           ; Llama a la funcion WriteFile para escribir el mensaje en la consola
   137                                      ;times 2 db 0x90
   138                                  
   139                                      ; Salir del programa
   140                                      ; ExitProcess(0)
   141 0000007E 6A00                        push 0                       ; Parametro: exitCode (0)
   142 00000080 E8(00000000)                call _ExitProcess@4          ; Llama a la funcion ExitProcess para terminar el programa
   143                                  
   144                                  
   145                                  section .data
   146 00000000 48656C6C6F2C20576F-         message db 'Hello, World!', 0xa, 0x0  ; Definición del mensaje a mostrar en la consola
   146 00000009 726C64210A00       
   147                                      lengthmessage: equ $-message
   148                                  
   149 0000000F 47656E75696E65496E-         procesadorIntel db "GenuineIntel", 0xa, 0x0
   149 00000018 74656C0A00         
   150                                      lengthprocesadorIntel: equ $-procesadorIntel
   151 0000001D 41757468656E746963-         procesadorAMD   db "AuthenticAMD", 0xa, 0x0
   151 00000026 414D440A00         
   152                                      ;lengthprocesadorAMD: equ $-procesadorAMD
   153                                  
   154                                  ;times 510 -( $ - $$ ) db 0
>>>>>>> ef5e781ab119ef5c749ce4c84477cc2f4e012d7c
