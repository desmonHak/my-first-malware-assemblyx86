[bits 32]

;extern  _GLOBAL_OFFSET_TABLE_   ; in ELF 
;extern  __GLOBAL_OFFSET_TABLE_  ; in BSD

; OF = 1 
%define JumpIfOverflow(symbol) jo symbol

; OF = 0 
%define JumpIfNotOverflow(symbol) jno symbol

; SF = 1 
%define JumpIfSign(symbol) js symbol

; SF = 0 
%define JumpIfNotSign(symbol) jns symbol

; ZF = 1 	 
%define JumpIfEqual(symbol) je symbol

;ZF = 0
%define JumpIfNotEqual(symbol) jne symbol

; ZF = 1 	 
%define JumpIfZero(symbol) jz symbol

; ZF = 0 
%define JumpIfNotZero(symbol) jnz symbol

%define STD_OUTPUT_HANDLE -11
%define true 1
%define false 0

%define SIZE_INT8  1
%define SIZE_INT16 2
%define SIZE_INT32 4
%define SIZE_INT64 8
%define SIZE_INT(bits) bits/8

section .bss nobits    alloc  noexec  write
    cpu_name resb 12

section .rodata  progbits  alloc  noexec  nowrite

section .text progbits  alloc  exec    nowrite
    global _WinMain@16           ; Declaracion de la funcion principal del programa
    extern _GetStdHandle@4       ; Declaracion de la funcion GetStdHandle de Windows
    extern _WriteFile@20         ; Declaracion de la funcion WriteFile de Windows
    extern _ExitProcess@4        ; Declaracion de la funcion ExitProcess de Windows

;; global _myfunc 
;; _myfunc:  push bp 
;;           mov bp,sp 
;;           sub sp,0x40            ; 64 bytes of local stack space 
;;           mov bx,[bp+4]          ; first parameter to function 
;;           ; some more code 
;;           mov sp,bp              ; undo "sub sp,0x40" above 
;;           pop bp 
;;           ret

cpuid_:
    push ebp
    mov ebp, esp
    ;sub esp

    ; "GenuineIntel" = 0x47,0x65,0x6e,0x75,0x69,0x6e,0x65,0x49,0x6e,0x74,0x65,0x6c

    pusha
    xor eax, eax ; EAX = 0
    cpuid ; cpuid(EAX = 0) -> return char*(ebx, edx, ecx)
    mov [cpu_name], ebx
    mov [cpu_name+4], edx
    mov [cpu_name+8], ecx
    
    cmp ebx, 0x756e6547 ; Genu(0x47656e75) -> uneG(0x756e6547)
    popa

    push 0
    ; El procesador es Intel
    mov dword [esp+4], 0 
    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    push eax


    JumpIfNotEqual(.next_if)
    ;JumpIfEqual(._thisIntel)

    ._thisIntel:   
    
        ; El procesador es Intel
        ;mov dword ptr [esp+4], 0 
        ;lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten

        ;sub esp, 4*3

        ;push eax                     ; Parametro: lpNumberOfBytesWritten
        push dword lengthprocesadorIntel; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
        push procesadorIntel                 ; Parametro: lpBuffer (puntero al mensaje)
        push ebx                     ; Parametro: hFile (identificador de la salida estándar)
        call _WriteFile@20
        xor eax, eax
        jmp ._return

    .next_if:
        cmp ebx, 0x68747541 ; Auth(0x41757468) -> htuA(0x68747541)
        ;JumpIfEqual(._thisAMD)
        JumpIfNotEqual(._err)

    ._thisAMD:   
        ; El procesador es AMD
        ;lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
        ;push eax                     ; Parametro: lpNumberOfBytesWritten
        push dword lengthprocesadorIntel; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
        push procesadorAMD                 ; Parametro: lpBuffer (puntero al mensaje)
        push ebx                     ; Parametro: hFile (identificador de la salida estándar)
        call _WriteFile@20
        xor eax, eax
        jmp ._return

    ._err:
        ; eax = -1
        xor eax, eax
        not eax
        ; return -1

    ._return:
        ;mov esp, ebp
        ;pop ebp
        leave ; mov esp,ebp / pop ebp 
        ret
        ; return ?


_WinMain@16:

    ; Reservar espacio en la pila para la variable local
    sub esp, 4

    ; Obtener el identificador de la salida estándar
    ; HANDLE ebx = GetStdHandle(DWORD STD_OUTPUT_HANDLE)
    push STD_OUTPUT_HANDLE       ; Parametro: STD_OUTPUT_HANDLE (-11)
    call _GetStdHandle@4         ; Llama a la funcion GetStdHandle para obtener el identificador de la salida estándar
    mov ebx, eax                 ; Almacena el identificador de la salida estándar en ebx

    call cpuid_

    ;cli ; desactivar interupciones IF = 0

    ; Escribir el mensaje en la salida estándar
    ; BOOL WriteFile(
    ;   [in]                HANDLE       hFile,
    ;   [in]                LPCVOID      lpBuffer,
    ;   [in]                DWORD        nNumberOfBytesToWrite,
    ;   [out, optional]     LPDWORD      lpNumberOfBytesWritten,
    ;   [in, out, optional] LPOVERLAPPED lpOverlapped
    ; );
    ; WriteFile(ebx, message, lengthmessage, eax, 0)    
    jmp ._a
    ;db 0x90, 0xaf, 0x11, 0xa0, 0x90, 0x90, 0xaf, 0x11, 0xa0, 0x90
    ._a:
    push 0                       ; Parametro: lpOverlapped (0)

    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    push eax                     ; Parametro: lpNumberOfBytesWritten
    push dword lengthmessage     ; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
    push message                 ; Parametro: lpBuffer (puntero al mensaje)
    push ebx                     ; Parametro: hFile (identificador de la salida estándar)

    ;times 5 dw 0xcd10
    jmp ._b
    ._b:
    ;sti ; activar interupciones IF = 1
    call _WriteFile@20           ; Llama a la funcion WriteFile para escribir el mensaje en la consola
    ;times 2 db 0x90

    ; Salir del programa
    ; ExitProcess(0)
    push 0                       ; Parametro: exitCode (0)
    call _ExitProcess@4          ; Llama a la funcion ExitProcess para terminar el programa


section .data progbits  alloc  noexec  write
    message db 'Hello, World!', 0xa, 0x0  ; Definición del mensaje a mostrar en la consola
    lengthmessage: equ $-message

    procesadorIntel db "GenuineIntel", 0xa, 0x0
    lengthprocesadorIntel: equ $-procesadorIntel
    procesadorAMD   db "AuthenticAMD", 0xa, 0x0
    ;lengthprocesadorAMD: equ $-procesadorAMD

;segment _DATA 

;times 510 -( $ - $$ ) db 0
