[bits 32]

;extern  _GLOBAL_OFFSET_TABLE_   ; in ELF 
;extern  __GLOBAL_OFFSET_TABLE_  ; in BSD

; OF = 1 
%define JumpIfOverflow(symbol) jo symbol

; OF = 0 
%define JumpIfNotOverflow(symbol) jno symbol

; SF = 1 
%define JumpIfSign(symbol) js symbol

; SF = 0 
%define JumpIfNotSign(symbol) jns symbol

; ZF = 1 	 
%define JumpIfEqual(symbol) je symbol

;ZF = 0
%define JumpIfNotEqual(symbol) jne symbol

; ZF = 1 	 
%define JumpIfZero(symbol) jz symbol

; ZF = 0 
%define JumpIfNotZero(symbol) jnz symbol

%define STD_OUTPUT_HANDLE -11
%define true 1
%define false 0

%define SIZE_INT8  1
%define SIZE_INT16 2
%define SIZE_INT32 4
%define SIZE_INT64 8
%define SIZE_INT(bits) bits/8

section .bss nobits    alloc  noexec  write
    cpu_name resb 13
    stdio resb 4

section .rodata  progbits  alloc  noexec  nowrite

section .text progbits  alloc  exec    nowrite
    global _WinMain@16           ; Declaracion de la funcion principal del programa
    extern _GetStdHandle@4       ; Declaracion de la funcion GetStdHandle de Windows
    extern _WriteFile@20         ; Declaracion de la funcion WriteFile de Windows
    extern _ExitProcess@4        ; Declaracion de la funcion ExitProcess de Windows
    extern _GetModuleHandleA@4

;; global _myfunc 
;; _myfunc:  push bp 
;;           mov bp,sp 
;;           sub sp,0x40            ; 64 bytes of local stack space 
;;           mov bx,[bp+4]          ; first parameter to function 
;;           ; some more code 
;;           mov sp,bp              ; undo "sub sp,0x40" above 
;;           pop bp 
;;           ret

_IdFromBytesMem:
	push	ebp
	mov	ebp, esp
	sub	esp, 16
	mov	DWORD  [ebp-4], 0
    L8:
        cmp	DWORD  [ebp-4], 22
        ja	L10
        mov	edx, DWORD  [ebp+8]
        mov	eax, DWORD  [ebp-4]
        add	eax, edx
        movzx	eax, BYTE  [eax]
        cmp	al, -72
        jne	L6
        mov	eax, DWORD  [ebp-4]
        lea	edx, [eax+1]
        mov	eax, DWORD  [ebp+8]
        add	eax, edx
        movzx	eax, WORD  [eax]
        jmp	L7
    L6:
        add	DWORD  [ebp-4], 1
        jmp	L8
    L10:
        nop
        mov	eax, 0
    L7:
        leave
        ret

_GetSyscallIdMem:
	push	ebp
	mov	ebp, esp
	sub	esp, 72
	mov	DWORD  [esp], ntdll_string
	mov	eax, DWORD  _GetModuleHandleA@4
	call	eax
	sub	esp, 4
	mov	DWORD  [ebp-24], eax
	cmp	DWORD  [ebp-24], 0
	jne	L12
	mov	eax, -1
	jmp	L13
    L12:
        mov	eax, DWORD  [ebp-24]
        mov	DWORD  [ebp-28], eax
        mov	eax, DWORD  [ebp-28]
        mov	eax, DWORD  [eax+60]
        mov	edx, eax
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-32], eax
        mov	eax, DWORD  [ebp-32]
        mov	edx, DWORD  [eax+120]
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-36], eax
        mov	eax, DWORD  [ebp-36]
        mov	edx, DWORD  [eax+32]
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-40], eax
        mov	eax, DWORD  [ebp-36]
        mov	edx, DWORD  [eax+28]
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-44], eax
        mov	eax, DWORD  [ebp-36]
        mov	edx, DWORD  [eax+36]
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-48], eax
        mov	DWORD  [ebp-12], 0
        jmp	L14
    L20:
        mov	eax, DWORD  [ebp-12]
        lea	edx, [0+eax*4]
        mov	eax, DWORD  [ebp-40]
        add	eax, edx
        mov	edx, DWORD  [eax]
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-52], eax
        mov	eax, DWORD  [ebp+8]
        mov	DWORD  [esp+4], eax
        mov	eax, DWORD  [ebp-52]
        mov	DWORD  [esp], eax
        call	compare_strings
        test	eax, eax
        je	L15
        add	DWORD  [ebp-12], 1
        jmp	L14
    L15:
        mov	eax, DWORD  [ebp-12]
        lea	edx, [eax+eax]
        mov	eax, DWORD  [ebp-48]
        add	eax, edx
        movzx	eax, WORD  [eax]
        movzx	eax, ax
        lea	edx, [0+eax*4]
        mov	eax, DWORD  [ebp-44]
        add	eax, edx
        mov	edx, DWORD  [eax]
        mov	eax, DWORD  [ebp-24]
        add	eax, edx
        mov	DWORD  [ebp-56], eax
        mov	DWORD  [ebp-20], 0
    L19:
        cmp	DWORD  [ebp-20], 22
        ja	L22
        mov	edx, DWORD  [ebp-56]
        mov	eax, DWORD  [ebp-20]
        add	eax, edx
        movzx	eax, BYTE  [eax]
        cmp	al, -72
        jne	L18
        mov	eax, DWORD  [ebp-20]
        lea	edx, [eax+1]
        mov	eax, DWORD  [ebp-56]
        add	eax, edx
        movzx	eax, WORD  [eax]
        mov	WORD  [ebp-14], ax
    L18:
        add	DWORD  [ebp-20], 1
        jmp	L19
    L22:
        nop
        movzx	eax, WORD  [ebp-14]
        jmp	L13
    L14:
        mov	eax, DWORD  [ebp-36]
        mov	eax, DWORD  [eax+24]
        cmp	DWORD  [ebp-12], eax
        jb	L20
        mov	eax, 0
    L13:
        leave
        ret


cpuid_:
    push ebp
    mov ebp, esp
    sub esp, 4

    ; Obtener info del procesador:
    ; https://en.wikipedia.org/wiki/CPUID
    xor eax, eax
    cpuid ; cpuid(eax = 0)
    mov [cpu_name], ebx
    mov [cpu_name+4], edx
    mov [cpu_name+8], ecx
    mov byte [cpu_name+12], 0xa ; introducir un salto de linea
    
    xor eax, eax
    mov dword [ebp-4], eax ; lpOverlapped = 0
    lea eax, [ebp-4]
    push eax               ; lpNumberOfBytesWritten
    push 13                ; nNumberOfBytesToWrite
    push cpu_name          ; lpBuffer
    push dword [stdio]     ;hFile
    call _WriteFile@20
    ; WriteFile(
    ;   hFile = stdio, 
    ;   lpBuffer = cpu_name, 
    ;   nNumberOfBytesToWrite = 13, 
    ;   lpNumberOfBytesWritten = (DWORD)&lpOverlapped, 
    ;   lpOverlapped = 0
    ; );


    xor eax, eax ; return 0
    ;not eax ; return -1

    leave
    ret

; int compare_strings(char *str1, char *str2)
; 0 = equals; -1 = diferentes
compare_strings:
    push ebp
    mov ebp, esp

    ; Cargar los parámetros (direcciones de las cadenas) en registros
    mov esi, [ebp + 8]   ; Primer parámetro: dirección de la primera cadena
    mov edi, [ebp + 12]  ; Segundo parámetro: dirección de la segunda cadena

    ._compare_loop:
        lodsb            ; Cargar un carácter de la primera cadena en al
        cmp al, [edi]    ; Comparar el carácter cargado con el carácter correspondiente de la segunda cadena
        jne ._not_equal  ; Si los caracteres son diferentes, salir del bucle
        cmp al, 0
        je ._equal       ; Si el carácter es nulo (fin de cadena), salir del bucle

        inc edi            ; Incrementar la dirección de la segunda cadena
        jmp ._compare_loop ; Repetir el bucle

    ._not_equal:
        mov eax, -1 ; Retornar -1 (diferentes)
        jmp ._end

    ._equal:
        xor eax, eax ; Retornar 0 (iguales)
    ._end:
        leave
        ret



_WinMain@16:

    ; Reservar espacio en la pila para la variable local
    sub esp, 4

    ; Obtener el identificador de la salida estándar
    ; HANDLE stdio = GetStdHandle(DWORD STD_OUTPUT_HANDLE)
    push STD_OUTPUT_HANDLE       ; Parametro: STD_OUTPUT_HANDLE (-11)
    call _GetStdHandle@4         ; Llama a la funcion GetStdHandle para obtener el identificador de la salida estándar
    mov [stdio], eax             ; Almacena el identificador de la salida estándar en stdio

    push dword procesadorIntel
    push dword procesadorAMD
    call compare_strings

    cmp eax, 0
    je bb_

    call cpuid_
    bb_:

    ;cli ; desactivar interupciones IF = 0

    ; Escribir el mensaje en la salida estándar
    ; BOOL WriteFile(
    ;   [in]                HANDLE       hFile,
    ;   [in]                LPCVOID      lpBuffer,
    ;   [in]                DWORD        nNumberOfBytesToWrite,
    ;   [out, optional]     LPDWORD      lpNumberOfBytesWritten,
    ;   [in, out, optional] LPOVERLAPPED lpOverlapped
    ; );
    jmp ._a
    ;db 0x90, 0xaf, 0x11, 0xa0, 0x90, 0x90, 0xaf, 0x11, 0xa0, 0x90
    ._a:

    
    ;lea eax, [function_name]
    ;push eax
    ;extern _printf
    ;call _GetSyscallIdMem
    ;push ax
    ;push msg
    ;call	_printf

    push 0                       ; Parametro: lpOverlapped (0)
    lea eax, [esp+4]             ; Calcula la direccion del Parametro lpNumberOfBytesWritten
    push eax                     ; Parametro: lpNumberOfBytesWritten
    push dword lengthmessage     ; Parametro: nNumberOfBytesToWrite (longitud del mensaje)
    push message                 ; Parametro: lpBuffer (puntero al mensaje)
    push dword [stdio]           ; Parametro: hFile (identificador de la salida estándar)
    ; WriteFile(
    ;   hFile = stdio, 
    ;   lpBuffer = message, 
    ;   nNumberOfBytesToWrite = lengthmessage, 
    ;   lpNumberOfBytesWritten = (DWORD)&lpOverlapped, 
    ;   lpOverlapped = 0
    ; );

    ;times 5 dw 0xcd10
    jmp ._b
    ._b:
    ;sti ; activar interupciones IF = 1
    call _WriteFile@20           ; Llama a la funcion WriteFile para escribir el mensaje en la consola
    ;times 2 db 0x90







    ; Salir del programa
    ; ExitProcess(0)
    push 0                       ; Parametro: exitCode (0)
    call _ExitProcess@4          ; Llama a la funcion ExitProcess para terminar el programa


section .data progbits  alloc  noexec  write
    message db 'Hello, World!', 0xa, 0x0  ; Definición del mensaje a mostrar en la consola
    lengthmessage: equ $-message

    procesadorIntel db "GenuineIntel", 0xa, 0x0
    lengthprocesadorIntel: equ $-procesadorIntel
    procesadorAMD   db "AuthenticAMD", 0xa, 0x0
    ;lengthprocesadorAMD: equ $-procesadorAMD

    ntdll_string db "ntdll.dll",0x0
    lengthntdll_string: equ $-ntdll_string

    format_string db "Syscall ID for function '%s': %u", 10, 0
    function_name db "NtAlpcDeleteResourceReserve", 0
    msg db "Syscall ID for function '%s': %u", 0xa, 0x0


;segment _DATA 

;times 510 -( $ - $$ ) db 0
